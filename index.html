<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Rust for Justice</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                  <h1>Rust for your brain/team/justice.</h1>
                  <h2>Clint Byrum - Cloud Software Engineer, GoDaddy</h2>
                  <h6>Words are my own I do not speak for GoDaddy</h6>
                </section>
                <section>
                  <section>Programming Language Rant</section>
                  <section><h3>Systems Languages</h3><p/>
                    <ul>
                      <li>C and pointers were a revolution - Finally a HIGH level language</li>
                      <li>C++ -- HIGH level in that you need to be HIGH to appreciate it</li>
                      <li>C# -- Oh clever another horizontal line -- and foreach</li>
                      <li>C++11 -- Oh yeah we can have foreach too, but we still call it for.</li>
                      <li>ObjectiveC -- All your user base are belong to iPhone.</li>
                    </ul>
                  </section>
                  <section><h3>Systems Languages</h3><p/>
                    Every single C descendent puts memory safety on the user.
                  </section>
                  <section><h3>Enter Memory Safe Languages</h3>
                    Java*, Perl, PHP, Python, Ruby, node.js -- All do GC and take memory control away from programmer.<i><h6>*java still has pointers but doesn't do arthmetic on them</h6></i></section>
                  <section><h3>GC languages can struggle with concurrency</h3>
                    <ul>
                      <li>Java VM pauses threads to GC objects.</li>
                      <li>Python, Ruby, etc. have Global Interpreter Lock when executing Python code</li>
                    </ul>
                  </section>
                  <section><h3>Shiny New Sytems Languages</h3><p/>
                    <ul>
                      <li>Go - Compiled duck-typed and syntax sugar for concurrency. Runs inside Go runtime with GC to avoid memory management.</li>
                      <li>Rust - Compiled, strong-typed with generics. Explicit scoped memory management and object lifetimes expressed in language.</li>
                    </ul>
                  </section>
                  <section><h3>Why not Go?</h3><p/>
                    It's a great language, and easier to learn. But it only goes halfway into systems programming success, where Rust can give you as much control as C, and has the added bonus of Generics
                  </section>
                </section>
				<section>
                    <section>Rust For your Brain</section>
                    <section>
                      Explicit Mutability and borrow rules reduce need for unit tests
                      <aside class="notes">
                        The compiler can warn you when you've made something mutable that doesn't need to be.
                      </aside>
                    </section>
                    <section>
                      Strong typing also means not having to unit test as much.
                      <aside class="notes">
                        The compiler will error if you have passed the wrong object or tried to call methods /access attributes that don't exist.
                      </aside>
                    </section>
                    <section>
                      Trait system gives some of the dynamic language flexibility back
                      <aside class="notes">
                        Works a bit like C++ templates (UGHGGGG) but calling it traits helps you orient your brain toward what it is appropriate for vs. macros or other meta-programming techniques.
                      </aside>
                    </section>
                    <section>
                      <h3>"Fearless Concurrency" -- Go ahead and make a thread, we dare you</h3>
                      <ul>
                        <li>Explicit mutability makes it easy to find global mutation</li>
                        <li>Built in Send/Sync traits for objects are useful for identify thread safe objects</li>
                      </ul>
                    </section>
                    <section>
                      You can opt out of these safeguards when you need to.
                      <aside class="notes">
                        unsafe is quite common deep within libraries where unit tests are worth the time to write. The key is that safety is the default, so most of the itime you can refactor the code without worrying about breaking things.
                      </aside>
                    </section>
                    <section>
                      Opt-in to garbage collection when you need flexible data ownership.
                      <aside class="notes">
                        It's incredible to be able to look at any section of code and know for sure if there is reference counted GC going on.
                      </aside>
                    </section>
                </section>
                <section>
                  <section>Rust For Your Team</section>
                  <section><h3>For your dev team...</h3>
                    Programming languages aren't just for computers.<p/>
                    Having explicit mutability and reference lifetimes helps be clear to humans too.
                  </section>
                  <section>
                    English/Chinese/Spanish/Hindi/etc. are all terrible at representing abstract concepts succinctly and clearly. Say it with code!
                  </section>
                  <section><h3>For your ops team...</h3>
                    Finding bugs at compile time means throwing better stuff over the wall to ops*.<p/>
                    Using a system level language should usually mean better performance and smaller footprint too.
                    <aside class="notes">
                      * Be DevOps. The real DevOps, where Dev and Ops seek to understand eachother.
                    </aside>
                  </section>
                  <section><h3>For your Dev & Ops...</h3>
                    <ul>
                      <li>How things get built and deploy matters. Ruby/Perl/Python packaging can be a nightmare.</li>
                      <li>C/C++ have layers on layers of dependency hell even after existing for 30 years.</li>
                    </ul>
                  </section>
                  <section><h3>New languages have better package/build/deploy stories.</h3>
                    <ul>
                      <li>Go has nice tie-ins with git and builds static binaries</li>
                      <li>Rust's "Cargo" tool is extremely well thought out and well integrated with crates.io for easy code re-use.</li>
                    </ul>
                  </section>
                </section>
				<section>
                  <section>Rust For Justice</section>
                  <section>Firefox is a browser aimed at freedom and privacy, and its authors, Mozilla.org, invented Rust.</section>
                  <section><h2>Firefox Quantum</h2> is the beta test of the next generation Firefox version.
                    <ul>
                      <li>HTML Rendering engine rewritten in Rust -- "Servo"</li>
                      <li>CSS Rendering engine rewritten in Rust to be parallelized</li>
                    </ul>
                  </section>
                  <section><h3>Why would they do that?</h3>
                    <ul>
                      <li>Firefox's original C++-bound memory model is basically why Google Chrome/Chromium exists.</li>
                      <li>Rust authors experimented with the idea that less garbage collection and memory tied more concretely to scope would beat the Process memory model in the long run</li>
                    </ul>
                  </section>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
